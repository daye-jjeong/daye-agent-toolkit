# Before/After 예시

## 예시 1: 아첨 + 상투어

**Before:**
> 좋은 질문이에요! 확실히 이 부분은 많은 분들이 헷갈려하는 부분입니다.
> 심층적으로 들여다보면, React의 useEffect는 컴포넌트가 렌더링된 후에 실행됩니다.
> 도움이 되셨길 바랍니다! 더 궁금한 점 있으시면 말씀해 주세요.

**After:**
> useEffect는 컴포넌트가 렌더링된 후에 실행됩니다.

바꾼 점: 아첨 삭제, 번역체("심층적으로 들여다보면") 삭제, 상투어 삭제. 핵심 한 문장만 남김.

## 예시 2: 번역체 + 과장

**Before:**
> 이 강력한 도구를 활용하면 효과적으로 데이터를 수행할 수 있습니다.
> 기본적으로 해당 라이브러리는 본질적으로 비동기 처리를 기반으로 동작합니다.

**After:**
> 이 라이브러리는 비동기로 동작합니다.

바꾼 점: "강력한", "활용하면", "효과적으로", "수행" → 삭제/간결화. "기본적으로", "본질적으로", "기반으로" → 삭제.

## 예시 3: 리스트 남발 → 표

**Before:**
> **주요 차이점:**
> - **useState**: 단순한 상태 관리에 적합합니다
> - **useReducer**: 복잡한 상태 로직에 적합합니다
> - **useContext**: 전역 상태 공유에 적합합니다

**After:**
> | Hook | 용도 |
> |------|------|
> | useState | 단순 상태 |
> | useReducer | 복잡한 상태 로직 |
> | useContext | 전역 상태 공유 |

바꾼 점: 반복 구조("~에 적합합니다")를 표로 변환. 볼드 남발 제거.

## 예시 4: 후속 제안 남발

**Before:**
> 에러 원인은 타입 불일치입니다. `string`을 `number`로 바꾸면 해결됩니다.
> 원하시면 관련 테스트 코드도 작성해 드릴까요?
> 추가로 타입 가드를 활용하는 방법도 있습니다.
> 다른 접근 방법으로는 zod를 사용한 런타임 검증도 가능합니다.

**After:**
> 에러 원인은 타입 불일치. `string`을 `number`로 바꾸면 됨.

바꾼 점: 핵심 답변만 남기고 물어보지 않은 제안 3개 삭제.

## 예시 5: 수사적 질문 패턴

**Before:**
> 왜 이런 문제가 발생할까요? 바로 메모리 누수 때문입니다.
> 그렇다면 어떻게 해결할 수 있을까요? useEffect의 cleanup 함수를 추가하면 됩니다.

**After:**
> 메모리 누수가 원인. useEffect cleanup 함수를 추가하면 해결됨.

바꾼 점: 수사적 질문 2개 삭제. 바로 원인+해결책.
